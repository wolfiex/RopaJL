<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .pnode {
        font: 300 11px "Helvetica Neue", Helvetica, Arial, sans-serif;
        fill: #bbb;
    }

    .node:hover {
        fill: #000;
    }

    .plink {
        stroke-opacity: .4;
        fill: none;
        pointer-events: none;
    }

    .node:hover,
    .node--source,
    .node--target {
        font-weight: 700;
    }

    .node--source {
        fill: #2ca02c;
    }

    .node--target {
        fill: #d62728;
    }

    .link--source,
    .link--target {
        stroke-opacity: 1;
        stroke-width: 2px;
    }

    .link--source {
        stroke: #d62728;
    }

    .link--target {
        stroke: #2ca02c;
    }

</style>
<body>
    <script src="https://d3js.org/d3.v4.min.js"></script>
<script>
var diameter = d3.min([window.innerWidth, window.innerHeight]),
  radius = diameter / 2,
  innerRadius = radius - 120;

var cluster = d3.cluster().size([360, innerRadius]);

const line = d3
  .radialLine()
  .radius(function(d) {
    return d.y;
  })
  .angle(function(d) {
    return d.x / 180 * Math.PI;
  })
  .curve(d3.curveBundle.beta(0.95));

var svg = d3
  .select("body")
  .append("svg")
  .attr("width", diameter)
  .attr("height", diameter)
  .append("g")
  .attr("transform", "translate(" + radius + "," + radius + ")");

var link = svg.append("g").selectAll(".link"),
  node = svg.append("g").selectAll(".node");

window.data = {};
window.names = {};
window.groups = [];
window.species = [];
window.selection = 8;

window.color = d3.interpolateCubehelixLong.gamma(4.1)("#F6089E", "#3864EB");
window.bluepink = d3.interpolate("#F6089E", "#3864EB");
window.cat = d3.scaleOrdinal(d3.schemeCategory20);
window.cat = d3.schemeCategory20;
/*





*/

d3.json("../reactionedges.json", function(error, classes) {
  if (error) throw error;
  // filter for groups here

  window.groups = [...new Set(classes.map(d => d[3]))];
  console.log(groups);

  var classes = classes.map(d => {
    if (d[3] != groups[window.selection]) d[1] = undefined;
    return d;
  });

  window.names = d3
    .nest()
    .key(function(d) {
      return d[0];
    })
    .rollup(function(v) {
      var imp = v.map(d => d[1]);
      var filterimport = imp.filter(d => {
        if (d != undefined) {
          window.species.push(d);
          return 1;
        }
      });
      return {
        reaction: v.map(d => d[2]),
        size: filterimport.length,
        imports: filterimport
      };
    })
    .entries(classes);

  window.data = names.map(e => {
    return {
      name: "e." + e.key,
      imports: e.value.imports.map(d => "e." + d),
      size: e.value.size,
      value: e.value
    };
  });

  var root = d3.hierarchy(packageHierarchy(window.data), d => d.children);

  var links = packageImports(root.descendants());

  console.dir(links);

  cluster(root);

  console.log(links);

  var nodes = root.descendants();
  window.species = new Set(window.species.map(d => "e." + d));
  link = link
    .data(links)
    .enter()
    .append("path")
    .attr("class", "link")
    //.merge(edges)
    .attr("d", d => {
      try {
        return line(d.source.path(d.target));
      } catch (err) {
        //console.log(err, d);
      }
    })
    .style("fill", "none")
    .style("opacity", d => Math.pow(1 - d.weight, 2))
    .style("stroke-width", d => 3 * Math.pow(1 - d.weight, 2))
    .style("stroke", window.cat[selection]); //d => window.color(d.weight));

  node = node
    .data(
      nodes.filter(function(n) {
        return !n.children;
      })
    )
    .enter()
    .append("text")
    .attr("class", "node")
    .attr("dy", ".31em")
    .attr("transform", function(d) {
      return "rotate(" +
        (d.x - 90) +
        ")translate(" +
        (d.y + 8) +
        ",0)" +
        (d.x < 180 ? "" : "rotate(180)");
    })
    .style("font", "11px Helvetica Neue, Helvetica, Arial, sans-serif")
    .style("opacity", d => {
      return window.species.has(d.data.name) | d.data.size > 0 ? 1 : 0.1;
    })
    .style("text-anchor", function(d) {
      return d.x < 180 ? "start" : "end";
    })
    .text(function(d) {
      return d.data.key;
    })
    .on("mouseover", mouseovered)
    .on("mouseout", mouseouted);
});

text = svg
  .append("text")
  .text("Hello world!")
  .attr("dy", "0.35em")
  .attr("transform", "translate(480,250)");

var text = d3
  .select(svg)
  .selectAll("text")
  .append("text")
  .attr("class", "label")
  .attr("dy", ".31em")
  .style("cx", "100px")
  .style("cy", "100px")
  .style("font", "11px Helvetica Neue, Helvetica, Arial, sans-serif")
  .style("text-anchor", "end")
  .style("fill", "black")
  .style("id", "label")
  .text(window.groups[window.selection]);

//

///

///

function mouseovered(d) {
  node.each(function(n) {
    n.target = n.source = false;
  });

  link
    .classed("link--target", function(l) {
      if (l.target === d) return l.source.source = true;
    })
    .classed("link--source", function(l) {
      if (l.source === d) return l.target.target = true;
    })
    .filter(function(l) {
      return l.target === d || l.source === d;
    })
    .each(function() {
      this.parentNode.appendChild(this);
    });

  node
    .classed("node--target", function(n) {
      return n.target;
    })
    .classed("node--source", function(n) {
      return n.source;
    });
}

function mouseouted(d) {
  console.log("mouseout", d.data.name);
  link.classed("link--target", false).classed("link--source", false);

  node.classed("node--target", false).classed("node--source", false);
}

d3.select(self.frameElement).style("height", diameter + "px");

// Lazily construct the package hierarchy from class names.
function packageHierarchy(classes) {
  var map = {};

  function find(name, data) {
    var node = map[name], i;
    if (!node) {
      node = map[name] = data || { name: name, children: [] };
      if (name.length) {
        node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
        node.parent.children.push(node);
        node.key = name.substring(i + 1);
      }
    }
    return node;
  }

  classes.forEach(function(d) {
    find(d.name, d);
  });

  return map[""];
}

// Return a list of imports for the given array of nodes.
function packageImports(nodes) {
  var map = {}, imports = [];

  // Compute a map from name to node.
  nodes.forEach(function(d) {
    map[d.data.name] = d;
  });

  // For each import, construct a link from the source to target node.
  nodes.forEach(function(d) {
    if (d.data.imports)
      d.data.imports.forEach(function(i, n) {
        imports.push({
          source: map[d.data.name],
          target: map[i],
          weight: d.data.value.reaction[n]
        });
      });
  });

  return imports;
}
</script>